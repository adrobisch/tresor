{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"tresor üîí"},{"location":"/index.html#tresor-","text":"tesor ( [t ÅeÀàzoÀê…êÃØ] ) is a Scala library to access secrets (credentials etc.) from different sources.","title":"tresor üîí"},{"location":"/index.html#features","text":"Provider for AES-256 encryption Providers for secrets from Hashicorp Vault engines (currently KV, Database, AWS) Integration with cats-effect Supports Scala 2.11, 2.12 Apache 2.0 licensed","title":"Features"},{"location":"/index.html#goals","text":"Provide an idiomatic access to mainstream ways of working with secrets in Scala\nFollow a light-weight approach, avoid feature creep and dependencies where possible","title":"Goals"},{"location":"/index.html#non-goals","text":"tresor will not\n‚Ä¶ be a full-blown authentication library\n‚Ä¶ support all Vault engines or API calls (should be easy enough to extend)\n‚Ä¶ integrate with other high-level libraries (this could be done in extra modules though)","title":"Non-Goals"},{"location":"/setup.html","text":"","title":"Setup"},{"location":"/setup.html#setup","text":"The latest version can be found here:\nAdd the dependency to your build:\nlibraryDependencies += \"com.drobisch\" %% \"tesor\" % \"0.1.10-SNAPSHOT\"","title":"Setup"},{"location":"/examples.html","text":"","title":"Examples"},{"location":"/examples.html#examples","text":"","title":"Examples"},{"location":"/examples.html#using-the-vault-key-value-engine","text":"The KV engine in vault lets you store arbitrary secrets in a JSON-object like manner. This will create non-refreshable (as in always valid) leases:\nimport cats.effect.{IO, Timer}\nimport scala.concurrent.ExecutionContext\nimport com.drobisch.tresor.vault._\n\nimplicit val executionContext: ExecutionContext = ???\nimplicit val timer: Timer[IO] = cats.effect.IO.timer(executionContext)\n\nval vaultConfig = VaultConfig(apiUrl = \"http://vault-host:8200/v1\", token = \"vault-token\")\n\nval kvSecret: IO[Lease] = KV[cats.effect.IO].secret(KeyValueContext(key = \"treasure\"), vaultConfig)","title":"Using the Vault Key Value Engine"},{"location":"/examples.html#using-the-aws-engine-with-auto-refresh","text":"The AWS engine create refreshable leases for which a reference can be used for storing. Usually you would create the reference in a safe way during application bootstrap, this has been omitted here:\nimport cats.effect.IO\nimport cats.effect.concurrent.Ref\nimport cats.effect.Timer\n\nimport com.drobisch.tresor.vault._\n\nimplicit val executionContext: scala.concurrent.ExecutionContext = ???\nimplicit val timer: Timer[IO] = cats.effect.IO.timer(executionContext)\n\nval vaultConfig = VaultConfig(apiUrl = s\"http://vault-host/v1\", token = \"vault-token\")\nval awsContext = AwsContext(name = \"some-role\")\nval initialLease: Ref[IO, Option[Lease]] = Ref.unsafe[IO, Option[Lease]](None)\n\nval leaseWithRefresh: IO[Lease] = AWS[IO].autoRefresh(initialLease)(AWS[IO].createCredentials(awsContext))(vaultConfig)","title":"Using the AWS Engine with auto-refresh"}]}